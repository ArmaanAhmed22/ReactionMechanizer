<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>reaction_mechanizer.drawing.mechanism_reaction_visualizer API documentation</title>
<meta name="description" content="Contains tools to visualize a reaction." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>reaction_mechanizer.drawing.mechanism_reaction_visualizer</code></h1>
</header>
<section id="section-intro">
<p>Contains tools to visualize a reaction.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Contains tools to visualize a reaction.
&#34;&#34;&#34;
from enum import Enum
from typing import Any, Dict, List, Tuple, Union
import typing
from reaction_mechanizer.pathway.reaction import DifferentialEquationModel, ReactionMechanism, SimpleStep
from scipy.integrate import odeint
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import seaborn as sns
import pandas as pd


class ReactionEvent(Enum):
    &#34;&#34;&#34;Enum for the possible reaction events, such as:\n
    CHANGE_CONCENTRATION: how much the concentration of the species should be changed by.
        Additional Info: Tuple(str: species of interest, float: change in concentration)
    SET_CONCENTRATION: what to set the concentration of the species to.
        Additional Info: Tuple(str: species of interest, float: new concentration)
    SMOOTH_CHANGE_CONCENTRATION: TBD
    &#34;&#34;&#34;
    CHANGE_CONCENTRATION = 0
    SET_CONCENTRATION = 1
    SMOOTH_CHANGE_CONCENTRATION = 2


class ReactionVisualizer:
    &#34;&#34;&#34;Visualier for either `SimpleStep` or `ReactionMechanism`
    &#34;&#34;&#34;
    def __init__(self, reaction: Union[SimpleStep, ReactionMechanism]):
        &#34;&#34;&#34;Create a `ReactionVisualizer` object to model the progression of a reaction

        Args:
            reaction (Union[SimpleStep, ReactionMechanism]): The reaction object to model
        &#34;&#34;&#34;
        self.reaction: Union[SimpleStep, ReactionMechanism] = reaction

    def get_states(self,
                   initial_state: Dict[str, float],
                   time_end: float,
                   number_steps: int,
                   initial_time: float = 0,
                   ode_override: Union[Dict[str, DifferentialEquationModel], None] = None) -&gt; Any:
        &#34;&#34;&#34;Get concentration of the species in this reaction, with model specifications given.

        Args:
            initial_state (Dict[str, float]): initial concentration of all species in reaction
            time_end (float): The end time for this model
            number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
            initial_time (float, optional): The time to start the model at. Defaults to 0.
            ode_override (Union[Dict[str, DifferentialEquationModel], None], optional):
                Dictionary containing the species to override the differential equation of using the provided one. Defaults to None.

        Returns:
            Any: 2D array where the rows represent the concentrations of the species at different times
                (between `initial_time` and `end_time` and using `number_steps`). The columns are the species in the order given by `initial_state`
        &#34;&#34;&#34;
        ode_dict: Dict[str, DifferentialEquationModel] = self.reaction.get_differential_equations()
        ode_dict_temp = {key: ode_dict[key] for key in initial_state.keys()}
        ode_dict = ode_dict_temp
        if ode_override is not None:
            for key, ode in ode_override.items():
                ode_dict[key] = ode
        ode_function = _get_simple_step_ode_function(ode_dict, list(initial_state.keys()))

        times = np.linspace(initial_time, time_end, number_steps)

        cur_state = list(initial_state.values())

        return odeint(ode_function, cur_state, times)

    def progress_reaction(self,
                          initial_state: Dict[str, float],
                          time_end: float,
                          number_steps: int,
                          events: Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None] = None,
                          out: Union[str, None] = None,
                          show_intermediates: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Generate model for reaction

        Args:
            initial_state (Dict[str, float]): initial concentration of all species in reaction
            time_end (float): The end time for this model
            number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
            events (Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None], optional):
                The list of events to occur during a specified time in the reaction. \
                    A single event is represented by a tuple holding the time of the perturbation, the type of perturbation (`ReactionEvent`), \
                        and the additional information associated with the `ReactionEvent` selected. Defaults to None.
            out (Union[str, None], optional):
                If a string is added, a png visually representing the reaction is created at the specified location (and a `DataFrame` is returned). \
                    Otherwise, just the `DataFrame` is returned. Defaults to None.
            show_intermediates (bool, optional): Whether to show the intermediate species in the graph (doesn&#39;t affect dataframe or `SimpleStep`s).

        Returns:
            pd.DataFrame: DataFrame representing the concentrations of the species in the reaction
        &#34;&#34;&#34;
        data: Any = np.ndarray((0, 0))
        if events is not None:
            sorted_events = (*sorted(events, key=lambda x: x[0]), (time_end, None, tuple()))
            cur_state = dict(initial_state)
            prev_time_point_discretized: float = 0

            for time_point, reaction_event_type, additional_info in sorted_events:
                # First, discretize the time points so that everything is measured to the granularity of &#34;number_steps&#34;
                time_interval = time_end / number_steps
                time_point_discretized = round(time_point / time_interval) * time_interval

                cur_number_steps = round((time_point - prev_time_point_discretized) / time_end * number_steps)

                cur_data = self.get_states(cur_state, time_point, cur_number_steps, initial_time=prev_time_point_discretized)
                data = cur_data if len(data) == 0 else typing.cast(Any, np.concatenate([data, cur_data]))

                if reaction_event_type == ReactionEvent.CHANGE_CONCENTRATION:
                    for index, key in enumerate(cur_state.keys()):
                        if key == additional_info[0]:
                            cur_state[key] = cur_data[-1, index] + additional_info[1]
                        else:
                            cur_state[key] = cur_data[-1, index]
                elif reaction_event_type == ReactionEvent.SET_CONCENTRATION:
                    for index, key in enumerate(cur_state.keys()):
                        if key == additional_info[0]:
                            cur_state[key] = cur_data[-1, index] + additional_info[1]
                        else:
                            cur_state[key] = cur_data[-1, index]
                elif reaction_event_type == ReactionEvent.SMOOTH_CHANGE_CONCENTRATION:
                    pass
                prev_time_point_discretized = time_point_discretized
        else:
            data = self.get_states(initial_state, time_end, number_steps)
        times = np.linspace(0, time_end, number_steps)

        _, ax = plt.subplots()
        plt.tight_layout()
        if out:
            dont_show: List[str] = []
            if not show_intermediates and type(self.reaction) == ReactionMechanism:
                dont_show.extend(self.reaction.get_intermediates())
            for i, thing in enumerate(initial_state.keys()):
                if thing not in dont_show:
                    sns.lineplot(x=times, y=data[:, i], label=&#34;$&#34;+thing+&#34;$&#34;, ax=ax)
            ax.legend()
            sns.despine(ax=ax)
            ax.margins(x=0, y=0)
            _, top = ax.get_ylim()
            ax.set_ylim([0, top*1.05])
            plt.savefig(str(out), bbox_inches=&#34;tight&#34;, dpi=600)
        return pd.DataFrame({&#34;Time&#34;: times, **{thing: data[:, i] for i, thing in enumerate(initial_state.keys())}})

    def animate_progress_reaction(self, video_destination_no_extension: str, video_length: float, fps: int, extension: str = &#34;mp4&#34;, **progress_reaction_args):
        &#34;&#34;&#34;Generate video visualization for reaction

        Args:
            video_destination_no_extension (str): The path to store the video at
            video_length (float): The length of the resulting video
            fps (int): The fps of the video
            extension (str, optional): The extensions of the video [example values: &#34;mp4&#34;, &#34;gif&#34;, &#34;mov&#34;, etc]. Defaults to &#34;mp4&#34;.
        &#34;&#34;&#34;
        df = self.progress_reaction(**progress_reaction_args)
        if not progress_reaction_args.get(&#34;show_intermediates&#34;, True) and type(self.reaction) == ReactionMechanism:
            df = df.drop(self.reaction.get_intermediates(), axis=&#34;columns&#34;)
        writer = animation.writers[&#34;ffmpeg&#34;](fps=fps, metadata={&#34;artist&#34;: &#34;ReactionMechanizer&#34;}, bitrate=1800)  # Non-python dependency!
        _, dummy_ax = plt.subplots()
        plt.tight_layout()
        df2 = df.drop(&#34;Time&#34;, axis=&#34;columns&#34;).stack().reset_index()  # level_1: species, 0: concentration values
        df2 = df2.rename({&#34;level_1&#34;: &#34;Species&#34;, 0: &#34;Concentration&#34;}, axis=&#34;columns&#34;)
        df2[&#34;Time&#34;] = [cur_time for cur_time in df[&#34;Time&#34;] for _ in df2[&#34;Species&#34;].unique()]
        sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=df2, hue=&#34;Species&#34;, ax=dummy_ax)
        _, top_y = dummy_ax.get_ylim()
        _, top_x = dummy_ax.get_xlim()

        new_fig, new_ax = plt.subplots()

        data_1_item = df2.iloc[:len(df2[&#34;Species&#34;].unique())]
        cur_data: Dict[str, Dict[str, List[float]]] = \
            {spec: {&#34;x&#34;: [data_1_item[&#34;Time&#34;].iloc[0]], &#34;y&#34;: [data_1_item[&#34;Concentration&#34;].iloc[i]]}
             for i, spec in enumerate(df2[&#34;Species&#34;].unique())}
        sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=data_1_item, hue=&#34;Species&#34;, ax=new_ax)
        new_ax.set_ylim([0, top_y*1.05])
        new_ax.set_xlim([0, top_x*1.05])
        new_ax.margins(x=0, y=0)
        sns.despine(ax=new_ax)

        def animate(frame_index):
            for i, spec in enumerate(df2[&#34;Species&#34;].unique()):
                cur_data[spec][&#34;x&#34;].append(df[&#34;Time&#34;].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
                cur_data[spec][&#34;y&#34;].append(df[spec].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
                new_ax.get_lines()[i].set_data(cur_data[spec][&#34;x&#34;], cur_data[spec][&#34;y&#34;])
        ani = animation.FuncAnimation(new_fig, animate, frames=video_length*fps, repeat=True)
        ani.save(f&#34;{video_destination_no_extension}.{extension}&#34;, writer=writer)


def _get_simple_step_ode_function(differential_equations: Dict[str, DifferentialEquationModel], state_order: List[str]):
    active_odes = {key: val.get_lambda() for key, val in differential_equations.items()}

    def simple_step_ode_function(cur_state, t):
        cur_state_order = state_order
        dict_state = {thing: val for thing, val in zip(cur_state_order, cur_state)}
        out = []
        for _, ode in active_odes.items():
            out.append(ode(**dict_state))
        return out
    return simple_step_ode_function</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent"><code class="flex name class">
<span>class <span class="ident">ReactionEvent</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum for the possible reaction events, such as:</p>
<p>CHANGE_CONCENTRATION: how much the concentration of the species should be changed by.
Additional Info: Tuple(str: species of interest, float: change in concentration)
SET_CONCENTRATION: what to set the concentration of the species to.
Additional Info: Tuple(str: species of interest, float: new concentration)
SMOOTH_CHANGE_CONCENTRATION: TBD</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReactionEvent(Enum):
    &#34;&#34;&#34;Enum for the possible reaction events, such as:\n
    CHANGE_CONCENTRATION: how much the concentration of the species should be changed by.
        Additional Info: Tuple(str: species of interest, float: change in concentration)
    SET_CONCENTRATION: what to set the concentration of the species to.
        Additional Info: Tuple(str: species of interest, float: new concentration)
    SMOOTH_CHANGE_CONCENTRATION: TBD
    &#34;&#34;&#34;
    CHANGE_CONCENTRATION = 0
    SET_CONCENTRATION = 1
    SMOOTH_CHANGE_CONCENTRATION = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.CHANGE_CONCENTRATION"><code class="name">var <span class="ident">CHANGE_CONCENTRATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SET_CONCENTRATION"><code class="name">var <span class="ident">SET_CONCENTRATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SMOOTH_CHANGE_CONCENTRATION"><code class="name">var <span class="ident">SMOOTH_CHANGE_CONCENTRATION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer"><code class="flex name class">
<span>class <span class="ident">ReactionVisualizer</span></span>
<span>(</span><span>reaction: Union[<a title="reaction_mechanizer.pathway.reaction.SimpleStep" href="../pathway/reaction.html#reaction_mechanizer.pathway.reaction.SimpleStep">SimpleStep</a>, <a title="reaction_mechanizer.pathway.reaction.ReactionMechanism" href="../pathway/reaction.html#reaction_mechanizer.pathway.reaction.ReactionMechanism">ReactionMechanism</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Visualier for either <code>SimpleStep</code> or <code>ReactionMechanism</code></p>
<p>Create a <code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer">ReactionVisualizer</a></code> object to model the progression of a reaction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reaction</code></strong> :&ensp;<code>Union[SimpleStep, ReactionMechanism]</code></dt>
<dd>The reaction object to model</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReactionVisualizer:
    &#34;&#34;&#34;Visualier for either `SimpleStep` or `ReactionMechanism`
    &#34;&#34;&#34;
    def __init__(self, reaction: Union[SimpleStep, ReactionMechanism]):
        &#34;&#34;&#34;Create a `ReactionVisualizer` object to model the progression of a reaction

        Args:
            reaction (Union[SimpleStep, ReactionMechanism]): The reaction object to model
        &#34;&#34;&#34;
        self.reaction: Union[SimpleStep, ReactionMechanism] = reaction

    def get_states(self,
                   initial_state: Dict[str, float],
                   time_end: float,
                   number_steps: int,
                   initial_time: float = 0,
                   ode_override: Union[Dict[str, DifferentialEquationModel], None] = None) -&gt; Any:
        &#34;&#34;&#34;Get concentration of the species in this reaction, with model specifications given.

        Args:
            initial_state (Dict[str, float]): initial concentration of all species in reaction
            time_end (float): The end time for this model
            number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
            initial_time (float, optional): The time to start the model at. Defaults to 0.
            ode_override (Union[Dict[str, DifferentialEquationModel], None], optional):
                Dictionary containing the species to override the differential equation of using the provided one. Defaults to None.

        Returns:
            Any: 2D array where the rows represent the concentrations of the species at different times
                (between `initial_time` and `end_time` and using `number_steps`). The columns are the species in the order given by `initial_state`
        &#34;&#34;&#34;
        ode_dict: Dict[str, DifferentialEquationModel] = self.reaction.get_differential_equations()
        ode_dict_temp = {key: ode_dict[key] for key in initial_state.keys()}
        ode_dict = ode_dict_temp
        if ode_override is not None:
            for key, ode in ode_override.items():
                ode_dict[key] = ode
        ode_function = _get_simple_step_ode_function(ode_dict, list(initial_state.keys()))

        times = np.linspace(initial_time, time_end, number_steps)

        cur_state = list(initial_state.values())

        return odeint(ode_function, cur_state, times)

    def progress_reaction(self,
                          initial_state: Dict[str, float],
                          time_end: float,
                          number_steps: int,
                          events: Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None] = None,
                          out: Union[str, None] = None,
                          show_intermediates: bool = True) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Generate model for reaction

        Args:
            initial_state (Dict[str, float]): initial concentration of all species in reaction
            time_end (float): The end time for this model
            number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
            events (Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None], optional):
                The list of events to occur during a specified time in the reaction. \
                    A single event is represented by a tuple holding the time of the perturbation, the type of perturbation (`ReactionEvent`), \
                        and the additional information associated with the `ReactionEvent` selected. Defaults to None.
            out (Union[str, None], optional):
                If a string is added, a png visually representing the reaction is created at the specified location (and a `DataFrame` is returned). \
                    Otherwise, just the `DataFrame` is returned. Defaults to None.
            show_intermediates (bool, optional): Whether to show the intermediate species in the graph (doesn&#39;t affect dataframe or `SimpleStep`s).

        Returns:
            pd.DataFrame: DataFrame representing the concentrations of the species in the reaction
        &#34;&#34;&#34;
        data: Any = np.ndarray((0, 0))
        if events is not None:
            sorted_events = (*sorted(events, key=lambda x: x[0]), (time_end, None, tuple()))
            cur_state = dict(initial_state)
            prev_time_point_discretized: float = 0

            for time_point, reaction_event_type, additional_info in sorted_events:
                # First, discretize the time points so that everything is measured to the granularity of &#34;number_steps&#34;
                time_interval = time_end / number_steps
                time_point_discretized = round(time_point / time_interval) * time_interval

                cur_number_steps = round((time_point - prev_time_point_discretized) / time_end * number_steps)

                cur_data = self.get_states(cur_state, time_point, cur_number_steps, initial_time=prev_time_point_discretized)
                data = cur_data if len(data) == 0 else typing.cast(Any, np.concatenate([data, cur_data]))

                if reaction_event_type == ReactionEvent.CHANGE_CONCENTRATION:
                    for index, key in enumerate(cur_state.keys()):
                        if key == additional_info[0]:
                            cur_state[key] = cur_data[-1, index] + additional_info[1]
                        else:
                            cur_state[key] = cur_data[-1, index]
                elif reaction_event_type == ReactionEvent.SET_CONCENTRATION:
                    for index, key in enumerate(cur_state.keys()):
                        if key == additional_info[0]:
                            cur_state[key] = cur_data[-1, index] + additional_info[1]
                        else:
                            cur_state[key] = cur_data[-1, index]
                elif reaction_event_type == ReactionEvent.SMOOTH_CHANGE_CONCENTRATION:
                    pass
                prev_time_point_discretized = time_point_discretized
        else:
            data = self.get_states(initial_state, time_end, number_steps)
        times = np.linspace(0, time_end, number_steps)

        _, ax = plt.subplots()
        plt.tight_layout()
        if out:
            dont_show: List[str] = []
            if not show_intermediates and type(self.reaction) == ReactionMechanism:
                dont_show.extend(self.reaction.get_intermediates())
            for i, thing in enumerate(initial_state.keys()):
                if thing not in dont_show:
                    sns.lineplot(x=times, y=data[:, i], label=&#34;$&#34;+thing+&#34;$&#34;, ax=ax)
            ax.legend()
            sns.despine(ax=ax)
            ax.margins(x=0, y=0)
            _, top = ax.get_ylim()
            ax.set_ylim([0, top*1.05])
            plt.savefig(str(out), bbox_inches=&#34;tight&#34;, dpi=600)
        return pd.DataFrame({&#34;Time&#34;: times, **{thing: data[:, i] for i, thing in enumerate(initial_state.keys())}})

    def animate_progress_reaction(self, video_destination_no_extension: str, video_length: float, fps: int, extension: str = &#34;mp4&#34;, **progress_reaction_args):
        &#34;&#34;&#34;Generate video visualization for reaction

        Args:
            video_destination_no_extension (str): The path to store the video at
            video_length (float): The length of the resulting video
            fps (int): The fps of the video
            extension (str, optional): The extensions of the video [example values: &#34;mp4&#34;, &#34;gif&#34;, &#34;mov&#34;, etc]. Defaults to &#34;mp4&#34;.
        &#34;&#34;&#34;
        df = self.progress_reaction(**progress_reaction_args)
        if not progress_reaction_args.get(&#34;show_intermediates&#34;, True) and type(self.reaction) == ReactionMechanism:
            df = df.drop(self.reaction.get_intermediates(), axis=&#34;columns&#34;)
        writer = animation.writers[&#34;ffmpeg&#34;](fps=fps, metadata={&#34;artist&#34;: &#34;ReactionMechanizer&#34;}, bitrate=1800)  # Non-python dependency!
        _, dummy_ax = plt.subplots()
        plt.tight_layout()
        df2 = df.drop(&#34;Time&#34;, axis=&#34;columns&#34;).stack().reset_index()  # level_1: species, 0: concentration values
        df2 = df2.rename({&#34;level_1&#34;: &#34;Species&#34;, 0: &#34;Concentration&#34;}, axis=&#34;columns&#34;)
        df2[&#34;Time&#34;] = [cur_time for cur_time in df[&#34;Time&#34;] for _ in df2[&#34;Species&#34;].unique()]
        sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=df2, hue=&#34;Species&#34;, ax=dummy_ax)
        _, top_y = dummy_ax.get_ylim()
        _, top_x = dummy_ax.get_xlim()

        new_fig, new_ax = plt.subplots()

        data_1_item = df2.iloc[:len(df2[&#34;Species&#34;].unique())]
        cur_data: Dict[str, Dict[str, List[float]]] = \
            {spec: {&#34;x&#34;: [data_1_item[&#34;Time&#34;].iloc[0]], &#34;y&#34;: [data_1_item[&#34;Concentration&#34;].iloc[i]]}
             for i, spec in enumerate(df2[&#34;Species&#34;].unique())}
        sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=data_1_item, hue=&#34;Species&#34;, ax=new_ax)
        new_ax.set_ylim([0, top_y*1.05])
        new_ax.set_xlim([0, top_x*1.05])
        new_ax.margins(x=0, y=0)
        sns.despine(ax=new_ax)

        def animate(frame_index):
            for i, spec in enumerate(df2[&#34;Species&#34;].unique()):
                cur_data[spec][&#34;x&#34;].append(df[&#34;Time&#34;].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
                cur_data[spec][&#34;y&#34;].append(df[spec].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
                new_ax.get_lines()[i].set_data(cur_data[spec][&#34;x&#34;], cur_data[spec][&#34;y&#34;])
        ani = animation.FuncAnimation(new_fig, animate, frames=video_length*fps, repeat=True)
        ani.save(f&#34;{video_destination_no_extension}.{extension}&#34;, writer=writer)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.animate_progress_reaction"><code class="name flex">
<span>def <span class="ident">animate_progress_reaction</span></span>(<span>self, video_destination_no_extension: str, video_length: float, fps: int, extension: str = 'mp4', **progress_reaction_args)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate video visualization for reaction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>video_destination_no_extension</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to store the video at</dd>
<dt><strong><code>video_length</code></strong> :&ensp;<code>float</code></dt>
<dd>The length of the resulting video</dd>
<dt><strong><code>fps</code></strong> :&ensp;<code>int</code></dt>
<dd>The fps of the video</dd>
<dt><strong><code>extension</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The extensions of the video [example values: "mp4", "gif", "mov", etc]. Defaults to "mp4".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def animate_progress_reaction(self, video_destination_no_extension: str, video_length: float, fps: int, extension: str = &#34;mp4&#34;, **progress_reaction_args):
    &#34;&#34;&#34;Generate video visualization for reaction

    Args:
        video_destination_no_extension (str): The path to store the video at
        video_length (float): The length of the resulting video
        fps (int): The fps of the video
        extension (str, optional): The extensions of the video [example values: &#34;mp4&#34;, &#34;gif&#34;, &#34;mov&#34;, etc]. Defaults to &#34;mp4&#34;.
    &#34;&#34;&#34;
    df = self.progress_reaction(**progress_reaction_args)
    if not progress_reaction_args.get(&#34;show_intermediates&#34;, True) and type(self.reaction) == ReactionMechanism:
        df = df.drop(self.reaction.get_intermediates(), axis=&#34;columns&#34;)
    writer = animation.writers[&#34;ffmpeg&#34;](fps=fps, metadata={&#34;artist&#34;: &#34;ReactionMechanizer&#34;}, bitrate=1800)  # Non-python dependency!
    _, dummy_ax = plt.subplots()
    plt.tight_layout()
    df2 = df.drop(&#34;Time&#34;, axis=&#34;columns&#34;).stack().reset_index()  # level_1: species, 0: concentration values
    df2 = df2.rename({&#34;level_1&#34;: &#34;Species&#34;, 0: &#34;Concentration&#34;}, axis=&#34;columns&#34;)
    df2[&#34;Time&#34;] = [cur_time for cur_time in df[&#34;Time&#34;] for _ in df2[&#34;Species&#34;].unique()]
    sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=df2, hue=&#34;Species&#34;, ax=dummy_ax)
    _, top_y = dummy_ax.get_ylim()
    _, top_x = dummy_ax.get_xlim()

    new_fig, new_ax = plt.subplots()

    data_1_item = df2.iloc[:len(df2[&#34;Species&#34;].unique())]
    cur_data: Dict[str, Dict[str, List[float]]] = \
        {spec: {&#34;x&#34;: [data_1_item[&#34;Time&#34;].iloc[0]], &#34;y&#34;: [data_1_item[&#34;Concentration&#34;].iloc[i]]}
         for i, spec in enumerate(df2[&#34;Species&#34;].unique())}
    sns.lineplot(x=&#34;Time&#34;, y=&#34;Concentration&#34;, data=data_1_item, hue=&#34;Species&#34;, ax=new_ax)
    new_ax.set_ylim([0, top_y*1.05])
    new_ax.set_xlim([0, top_x*1.05])
    new_ax.margins(x=0, y=0)
    sns.despine(ax=new_ax)

    def animate(frame_index):
        for i, spec in enumerate(df2[&#34;Species&#34;].unique()):
            cur_data[spec][&#34;x&#34;].append(df[&#34;Time&#34;].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
            cur_data[spec][&#34;y&#34;].append(df[spec].iloc[int(frame_index/(video_length*fps)*df.shape[0])])
            new_ax.get_lines()[i].set_data(cur_data[spec][&#34;x&#34;], cur_data[spec][&#34;y&#34;])
    ani = animation.FuncAnimation(new_fig, animate, frames=video_length*fps, repeat=True)
    ani.save(f&#34;{video_destination_no_extension}.{extension}&#34;, writer=writer)</code></pre>
</details>
</dd>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.get_states"><code class="name flex">
<span>def <span class="ident">get_states</span></span>(<span>self, initial_state: Dict[str, float], time_end: float, number_steps: int, initial_time: float = 0, ode_override: Optional[Dict[str, <a title="reaction_mechanizer.pathway.reaction.DifferentialEquationModel" href="../pathway/reaction.html#reaction_mechanizer.pathway.reaction.DifferentialEquationModel">DifferentialEquationModel</a>]] = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Get concentration of the species in this reaction, with model specifications given.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>initial concentration of all species in reaction</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>float</code></dt>
<dd>The end time for this model</dd>
<dt><strong><code>number_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>The granularity of this model. The higher the number of steps, the more accurate the model.</dd>
<dt><strong><code>initial_time</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The time to start the model at. Defaults to 0.</dd>
</dl>
<p>ode_override (Union[Dict[str, DifferentialEquationModel], None], optional):
Dictionary containing the species to override the differential equation of using the provided one. Defaults to None.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>2D array where the rows represent the concentrations of the species at different times
(between <code>initial_time</code> and <code>end_time</code> and using <code>number_steps</code>). The columns are the species in the order given by <code>initial_state</code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_states(self,
               initial_state: Dict[str, float],
               time_end: float,
               number_steps: int,
               initial_time: float = 0,
               ode_override: Union[Dict[str, DifferentialEquationModel], None] = None) -&gt; Any:
    &#34;&#34;&#34;Get concentration of the species in this reaction, with model specifications given.

    Args:
        initial_state (Dict[str, float]): initial concentration of all species in reaction
        time_end (float): The end time for this model
        number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
        initial_time (float, optional): The time to start the model at. Defaults to 0.
        ode_override (Union[Dict[str, DifferentialEquationModel], None], optional):
            Dictionary containing the species to override the differential equation of using the provided one. Defaults to None.

    Returns:
        Any: 2D array where the rows represent the concentrations of the species at different times
            (between `initial_time` and `end_time` and using `number_steps`). The columns are the species in the order given by `initial_state`
    &#34;&#34;&#34;
    ode_dict: Dict[str, DifferentialEquationModel] = self.reaction.get_differential_equations()
    ode_dict_temp = {key: ode_dict[key] for key in initial_state.keys()}
    ode_dict = ode_dict_temp
    if ode_override is not None:
        for key, ode in ode_override.items():
            ode_dict[key] = ode
    ode_function = _get_simple_step_ode_function(ode_dict, list(initial_state.keys()))

    times = np.linspace(initial_time, time_end, number_steps)

    cur_state = list(initial_state.values())

    return odeint(ode_function, cur_state, times)</code></pre>
</details>
</dd>
<dt id="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.progress_reaction"><code class="name flex">
<span>def <span class="ident">progress_reaction</span></span>(<span>self, initial_state: Dict[str, float], time_end: float, number_steps: int, events: Optional[List[Tuple[float, <a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent">ReactionEvent</a>, Tuple[Any]]]] = None, out: Optional[str] = None, show_intermediates: bool = True) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Generate model for reaction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>Dict[str, float]</code></dt>
<dd>initial concentration of all species in reaction</dd>
<dt><strong><code>time_end</code></strong> :&ensp;<code>float</code></dt>
<dd>The end time for this model</dd>
<dt><strong><code>number_steps</code></strong> :&ensp;<code>int</code></dt>
<dd>The granularity of this model. The higher the number of steps, the more accurate the model.</dd>
<dt>events (Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None], optional):</dt>
<dt>The list of events to occur during a specified time in the reaction.
A single event is represented by a tuple holding the time of the perturbation, the type of perturbation (<code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent">ReactionEvent</a></code>),
and the additional information associated with the <code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent">ReactionEvent</a></code> selected. Defaults to None.</dt>
<dt>out (Union[str, None], optional):</dt>
<dt>If a string is added, a png visually representing the reaction is created at the specified location (and a <code>DataFrame</code> is returned).
Otherwise, just the <code>DataFrame</code> is returned. Defaults to None.</dt>
<dt><strong><code>show_intermediates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to show the intermediate species in the graph (doesn't affect dataframe or <code>SimpleStep</code>s).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>DataFrame representing the concentrations of the species in the reaction</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_reaction(self,
                      initial_state: Dict[str, float],
                      time_end: float,
                      number_steps: int,
                      events: Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None] = None,
                      out: Union[str, None] = None,
                      show_intermediates: bool = True) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Generate model for reaction

    Args:
        initial_state (Dict[str, float]): initial concentration of all species in reaction
        time_end (float): The end time for this model
        number_steps (int): The granularity of this model. The higher the number of steps, the more accurate the model.
        events (Union[List[Tuple[float, ReactionEvent, Tuple[Any]]], None], optional):
            The list of events to occur during a specified time in the reaction. \
                A single event is represented by a tuple holding the time of the perturbation, the type of perturbation (`ReactionEvent`), \
                    and the additional information associated with the `ReactionEvent` selected. Defaults to None.
        out (Union[str, None], optional):
            If a string is added, a png visually representing the reaction is created at the specified location (and a `DataFrame` is returned). \
                Otherwise, just the `DataFrame` is returned. Defaults to None.
        show_intermediates (bool, optional): Whether to show the intermediate species in the graph (doesn&#39;t affect dataframe or `SimpleStep`s).

    Returns:
        pd.DataFrame: DataFrame representing the concentrations of the species in the reaction
    &#34;&#34;&#34;
    data: Any = np.ndarray((0, 0))
    if events is not None:
        sorted_events = (*sorted(events, key=lambda x: x[0]), (time_end, None, tuple()))
        cur_state = dict(initial_state)
        prev_time_point_discretized: float = 0

        for time_point, reaction_event_type, additional_info in sorted_events:
            # First, discretize the time points so that everything is measured to the granularity of &#34;number_steps&#34;
            time_interval = time_end / number_steps
            time_point_discretized = round(time_point / time_interval) * time_interval

            cur_number_steps = round((time_point - prev_time_point_discretized) / time_end * number_steps)

            cur_data = self.get_states(cur_state, time_point, cur_number_steps, initial_time=prev_time_point_discretized)
            data = cur_data if len(data) == 0 else typing.cast(Any, np.concatenate([data, cur_data]))

            if reaction_event_type == ReactionEvent.CHANGE_CONCENTRATION:
                for index, key in enumerate(cur_state.keys()):
                    if key == additional_info[0]:
                        cur_state[key] = cur_data[-1, index] + additional_info[1]
                    else:
                        cur_state[key] = cur_data[-1, index]
            elif reaction_event_type == ReactionEvent.SET_CONCENTRATION:
                for index, key in enumerate(cur_state.keys()):
                    if key == additional_info[0]:
                        cur_state[key] = cur_data[-1, index] + additional_info[1]
                    else:
                        cur_state[key] = cur_data[-1, index]
            elif reaction_event_type == ReactionEvent.SMOOTH_CHANGE_CONCENTRATION:
                pass
            prev_time_point_discretized = time_point_discretized
    else:
        data = self.get_states(initial_state, time_end, number_steps)
    times = np.linspace(0, time_end, number_steps)

    _, ax = plt.subplots()
    plt.tight_layout()
    if out:
        dont_show: List[str] = []
        if not show_intermediates and type(self.reaction) == ReactionMechanism:
            dont_show.extend(self.reaction.get_intermediates())
        for i, thing in enumerate(initial_state.keys()):
            if thing not in dont_show:
                sns.lineplot(x=times, y=data[:, i], label=&#34;$&#34;+thing+&#34;$&#34;, ax=ax)
        ax.legend()
        sns.despine(ax=ax)
        ax.margins(x=0, y=0)
        _, top = ax.get_ylim()
        ax.set_ylim([0, top*1.05])
        plt.savefig(str(out), bbox_inches=&#34;tight&#34;, dpi=600)
    return pd.DataFrame({&#34;Time&#34;: times, **{thing: data[:, i] for i, thing in enumerate(initial_state.keys())}})</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="reaction_mechanizer.drawing" href="index.html">reaction_mechanizer.drawing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent">ReactionEvent</a></code></h4>
<ul class="">
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.CHANGE_CONCENTRATION" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.CHANGE_CONCENTRATION">CHANGE_CONCENTRATION</a></code></li>
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SET_CONCENTRATION" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SET_CONCENTRATION">SET_CONCENTRATION</a></code></li>
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SMOOTH_CHANGE_CONCENTRATION" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionEvent.SMOOTH_CHANGE_CONCENTRATION">SMOOTH_CHANGE_CONCENTRATION</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer">ReactionVisualizer</a></code></h4>
<ul class="">
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.animate_progress_reaction" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.animate_progress_reaction">animate_progress_reaction</a></code></li>
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.get_states" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.get_states">get_states</a></code></li>
<li><code><a title="reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.progress_reaction" href="#reaction_mechanizer.drawing.mechanism_reaction_visualizer.ReactionVisualizer.progress_reaction">progress_reaction</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>